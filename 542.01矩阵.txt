这道题可以用DP（Dynamic programing）动态规划。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题依次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

经过两次遍历，分别判断左上和右下。

class Solution {
    public int[][] updateMatrix(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[][] out = new int[rows][cols];

        for(int i = 0;i<rows;i++){
            for(int j = 0;j<cols;j++){
                if(matrix[i][j] == 0){
                    out[i][j] = 0;
                }else{
                    out[i][j] = Integer.MAX_VALUE-1;
                    if(i>0){
                        out[i][j] = Math.min(out[i][j],out[i-1][j]+1);
                    }
                    if(j>0){
                        out[i][j] = Math.min(out[i][j],out[i][j-1]+1);
                    }
                }
            }
        }
        for(int i = rows-1;i>=0;i--){
            for(int j = cols-1;j>=0;j--){
                if(matrix[i][j]!=0){
                    if(i<rows-1){
                        out[i][j] = Math.min(out[i][j],out[i+1][j]+1);
                    }
                    if(j<cols-1){
                        out[i][j] = Math.min(out[i][j],out[i][j+1]+1);
                    }
                }
            }
        }
        return out;
    }
}